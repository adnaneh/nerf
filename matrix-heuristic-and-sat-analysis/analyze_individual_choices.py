#!/usr/bin/env python3
"""
Analyze individual choice success rates for the 16 outputs that have 2 pre-images each.
"""

# The 16 outputs with exactly 2 choices each (from our earlier analysis)
multi_choice_outputs = {
    0x02: [0x18, 0x5e],
    0x1c: [0x53, 0x71], 
    0x2d: [0x84, 0xdc],
    0x33: [0x06, 0x9a],
    0x49: [0x4d, 0xd1],
    0x57: [0xb8, 0xcf],
    0x66: [0x29, 0xb5],
    0x78: [0x15, 0x97],
    0x8d: [0x89, 0xab],
    0x93: [0xa6, 0xe0],
    0xa2: [0x3a, 0xf3],
    0xbc: [0x0b, 0xc2],
    0xc6: [0x37, 0x40],
    0xd8: [0x6f, 0xed],
    0xe9: [0x24, 0x7c],
    0xf7: [0x62, 0xfe]
}

print("=== Individual Choice Analysis ===\n")

print("The 16 outputs with 2 choices each:")
for output, choices in multi_choice_outputs.items():
    choice1, choice2 = choices
    print(f"Output 0x{output:02x}: choice1=0x{choice1:02x}, choice2=0x{choice2:02x}")

print(f"\nTo analyze individual choice success rates, we need to modify hireme2.c to log:")
print(f"1. Which specific choice was made for each multi-choice output")
print(f"2. Whether that choice led to success or failure")
print(f"3. The context (round, combination count, etc.)")

instrumentation_code = '''
// Add this to the DFS function to log individual choices

// After line where we compute new_state[j] = inv_low[v[j]][choice_idx]:
if (v_analysis_log && inv_low_count[v[j]] > 1) {
    fprintf(v_analysis_log, "CHOICE,%d,%d,0x%02x,%d,0x%02x\\n", 
            current_run_id, round, v[j], choice_idx, new_state[j]);
}

// This will create records like:
// CHOICE,run_id,round,output_value,choice_index,chosen_value
// Example: CHOICE,5,42,0x02,1,0x5e means run 5, round 42, output 0x02, chose index 1 (0x5e)
'''

print(f"\nInstrumentation needed:")
print(instrumentation_code)

print(f"\nAfter collecting this data, we can analyze:")
print(f"1. For output 0x02: Does choice 0x18 or 0x5e lead to more successes?")
print(f"2. For output 0x1c: Does choice 0x53 or 0x71 lead to more successes?")
print(f"3. And so on for all 16 multi-choice outputs...")

print(f"\nExpected insights:")
print(f"- Some choices may be universally better than others")
print(f"- Choice preference may depend on round number/context")
print(f"- We might find 'golden paths' through the choice space")
print(f"- This could lead to a deterministic optimal strategy")

# Analyze bit patterns of the choices to look for mathematical patterns
print(f"\n=== Mathematical Analysis of Choice Patterns ===")

for output, choices in multi_choice_outputs.items():
    choice1, choice2 = choices
    
    # Analyze bit patterns
    xor_pattern = choice1 ^ choice2
    bit_diff = bin(xor_pattern).count('1')
    
    # Analyze numerical patterns
    diff = abs(choice1 - choice2)
    larger = max(choice1, choice2)
    smaller = min(choice1, choice2)
    
    print(f"Output 0x{output:02x}:")
    print(f"  Choices: 0x{choice1:02x} vs 0x{choice2:02x}")
    print(f"  XOR pattern: 0x{xor_pattern:02x} ({bit_diff} bits different)")
    print(f"  Difference: {diff}, Ratio: {larger/smaller:.2f}")
    print(f"  Parity: {choice1%2} vs {choice2%2}")

# Look for common XOR patterns
print(f"\n=== XOR Pattern Analysis ===")
xor_patterns = {}
for output, choices in multi_choice_outputs.items():
    xor_pattern = choices[0] ^ choices[1]
    if xor_pattern not in xor_patterns:
        xor_patterns[xor_pattern] = []
    xor_patterns[xor_pattern].append(output)

print(f"Common XOR patterns between choice pairs:")
for pattern, outputs in xor_patterns.items():
    if len(outputs) > 1:
        print(f"  XOR 0x{pattern:02x}: outputs {[hex(o) for o in outputs]}")

print(f"\n=== Hypotheses to Test ===")
print(f"1. PARITY HYPOTHESIS: Even/odd choices might have different success rates")
print(f"2. MAGNITUDE HYPOTHESIS: Larger/smaller values might be better")
print(f"3. BIT PATTERN HYPOTHESIS: Specific bit patterns might correlate with success")
print(f"4. CONTEXT HYPOTHESIS: Choice preference might depend on round/depth")
print(f"5. FORWARD MAPPING HYPOTHESIS: Where each choice maps to next might matter")

# Show forward mapping analysis
confusion_s_low = [
    0xac,0xd1,0x25,0x94,0x1f,0xb3,0x33,0x28,0x7c,0x2b,0x17,0xbc,0xf6,0xb0,0x55,0x5d,
    0x8f,0xd2,0x48,0xd4,0xd3,0x78,0x62,0x1a,0x02,0xf2,0x01,0xc9,0xaa,0xf0,0x83,0x71,
    0x72,0x4b,0x6a,0xe8,0xe9,0x42,0xc0,0x53,0x63,0x66,0x13,0x4a,0xc1,0x85,0xcf,0x0c,
    0x24,0x76,0xa5,0x6e,0xd7,0xa1,0xec,0xc6,0x04,0xc2,0xa2,0x5c,0x81,0x92,0x6c,0xda,
    0xc6,0x86,0xba,0x4d,0x39,0xa0,0x0e,0x8c,0x8a,0xd0,0xfe,0x59,0x96,0x49,0xe6,0xea,
    0x69,0x30,0x52,0x1c,0xe0,0xb2,0x05,0x9b,0x10,0x03,0xa8,0x64,0x51,0x97,0x02,0x09,
    0x8e,0xad,0xf7,0x36,0x47,0xab,0xce,0x7f,0x56,0xca,0x00,0xe3,0xed,0xf1,0x38,0xd8,
    0x26,0x1c,0xdc,0x35,0x91,0x43,0x2c,0x74,0xb4,0x61,0x9d,0x5e,0xe9,0x4c,0xbf,0x77,
    0x16,0x1e,0x21,0x1d,0x2d,0xa9,0x95,0xb8,0xc3,0x8d,0xf8,0xdb,0x34,0xe1,0x84,0xd6,
    0x0b,0x23,0x4e,0xff,0x3c,0x54,0xa7,0x78,0xa4,0x89,0x33,0x6d,0xfb,0x79,0x27,0xc4,
    0xf9,0x40,0x41,0xdf,0xc5,0x82,0x93,0xdd,0xa6,0xef,0xcd,0x8d,0xa3,0xae,0x7a,0xb6,
    0x2f,0xfd,0xbd,0xe5,0x98,0x66,0xf3,0x4f,0x57,0x88,0x90,0x9c,0x0a,0x50,0xe7,0x15,
    0x7b,0x58,0xbc,0x07,0x68,0x3a,0x5f,0xee,0x32,0x9f,0xeb,0xcc,0x18,0x8b,0xe2,0x57,
    0xb7,0x49,0x37,0xde,0xf5,0x99,0x67,0x5b,0x3b,0xbb,0x3d,0xb5,0x2d,0x19,0x2e,0x0d,
    0x93,0xfc,0x7e,0x06,0x08,0xbe,0x3f,0xd9,0x2a,0x70,0x9a,0xc8,0x7d,0xd8,0x46,0x65,
    0x22,0xf4,0xb9,0xa2,0x6f,0x12,0x1b,0x14,0x45,0xc7,0x87,0x31,0x60,0x29,0xf7,0x73
]

print(f"\n=== Forward Mapping Analysis ===")
print(f"Where each choice maps to in the next round:")
for output, choices in multi_choice_outputs.items():
    choice1, choice2 = choices
    future1 = confusion_s_low[choice1]
    future2 = confusion_s_low[choice2]
    
    print(f"Output 0x{output:02x}: 0x{choice1:02x}→0x{future1:02x}, 0x{choice2:02x}→0x{future2:02x}")
    
    # Check if future outputs are also multi-choice
    future1_is_multi = future1 in multi_choice_outputs
    future2_is_multi = future2 in multi_choice_outputs
    
    if future1_is_multi or future2_is_multi:
        print(f"  Future multi-choice: {future1_is_multi} vs {future2_is_multi}")