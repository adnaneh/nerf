// =============================================================================
//  "Hire‑me" crack‑me – EXPLORATION VERSION for DFS Analysis
// =============================================================================
//
//  This version explores ALL possible DFS paths instead of stopping at the first solution.
//  It collects detailed data about each explored node and outputs to CSV format.
//
//  Data collected for each node:
//  - Choices made to reach this node (for each of the 16 values where inv_low gives choices)
//  - Whether it's on a winning path or not
//  - How many possible combinations we can choose for the next round
//  - Current depth in the search tree
//
// =============================================================================

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <math.h>

// SIMD includes for ARM64
#include <arm_neon.h>   // For NEON intrinsics on ARM64

typedef uint8_t  u8;
typedef uint32_t u32;

static const u8 confusion[512] = {
    0xac,0xd1,0x25,0x94,0x1f,0xb3,0x33,0x28,0x7c,0x2b,0x17,0xbc,0xf6,0xb0,0x55,0x5d,
    0x8f,0xd2,0x48,0xd4,0xd3,0x78,0x62,0x1a,0x02,0xf2,0x01,0xc9,0xaa,0xf0,0x83,0x71,
    0x72,0x4b,0x6a,0xe8,0xe9,0x42,0xc0,0x53,0x63,0x66,0x13,0x4a,0xc1,0x85,0xcf,0x0c,
    0x24,0x76,0xa5,0x6e,0xd7,0xa1,0xec,0xc6,0x04,0xc2,0xa2,0x5c,0x81,0x92,0x6c,0xda,
    0xc6,0x86,0xba,0x4d,0x39,0xa0,0x0e,0x8c,0x8a,0xd0,0xfe,0x59,0x96,0x49,0xe6,0xea,
    0x69,0x30,0x52,0x1c,0xe0,0xb2,0x05,0x9b,0x10,0x03,0xa8,0x64,0x51,0x97,0x02,0x09,
    0x8e,0xad,0xf7,0x36,0x47,0xab,0xce,0x7f,0x56,0xca,0x00,0xe3,0xed,0xf1,0x38,0xd8,
    0x26,0x1c,0xdc,0x35,0x91,0x43,0x2c,0x74,0xb4,0x61,0x9d,0x5e,0xe9,0x4c,0xbf,0x77,
    0x16,0x1e,0x21,0x1d,0x2d,0xa9,0x95,0xb8,0xc3,0x8d,0xf8,0xdb,0x34,0xe1,0x84,0xd6,
    0x0b,0x23,0x4e,0xff,0x3c,0x54,0xa7,0x78,0xa4,0x89,0x33,0x6d,0xfb,0x79,0x27,0xc4,
    0xf9,0x40,0x41,0xdf,0xc5,0x82,0x93,0xdd,0xa6,0xef,0xcd,0x8d,0xa3,0xae,0x7a,0xb6,
    0x2f,0xfd,0xbd,0xe5,0x98,0x66,0xf3,0x4f,0x57,0x88,0x90,0x9c,0x0a,0x50,0xe7,0x15,
    0x7b,0x58,0xbc,0x07,0x68,0x3a,0x5f,0xee,0x32,0x9f,0xeb,0xcc,0x18,0x8b,0xe2,0x57,
    0xb7,0x49,0x37,0xde,0xf5,0x99,0x67,0x5b,0x3b,0xbb,0x3d,0xb5,0x2d,0x19,0x2e,0x0d,
    0x93,0xfc,0x7e,0x06,0x08,0xbe,0x3f,0xd9,0x2a,0x70,0x9a,0xc8,0x7d,0xd8,0x46,0x65,
    0x22,0xf4,0xb9,0xa2,0x6f,0x12,0x1b,0x14,0x45,0xc7,0x87,0x31,0x60,0x29,0xf7,0x73,
    0x2c,0x97,0x72,0xcd,0x89,0xa6,0x88,0x4c,0xe8,0x83,0xeb,0x59,0xca,0x50,0x3f,0x27,
    0x4e,0xae,0x43,0xd5,0x6e,0xd0,0x99,0x7b,0x7c,0x40,0x0c,0x52,0x86,0xc1,0x46,0x12,
    0x5a,0x28,0xa8,0xbb,0xcb,0xf0,0x11,0x95,0x26,0x0d,0x34,0x66,0x22,0x18,0x6f,0x51,
    0x9b,0x3b,0xda,0xec,0x5e,0x00,0x2a,0xf5,0x8f,0x61,0xba,0x96,0xb3,0xd1,0x30,0xdc,
    0x33,0x75,0xe9,0x6d,0xc8,0xa1,0x3a,0x3e,0x5f,0x9d,0xfd,0xa9,0x31,0x9f,0xaa,0x85,
    0x2f,0x92,0xaf,0x67,0x78,0xa5,0xab,0x03,0x21,0x4f,0xb9,0xad,0xfe,0xf3,0x42,0xfc,
    0x17,0xd7,0xee,0xa3,0xd8,0x80,0x14,0x2e,0xa0,0x47,0x55,0xc4,0xff,0xe5,0x13,0x3f,
    0x81,0xb6,0x7a,0x94,0xd0,0xb5,0x54,0xbf,0x91,0xa7,0x37,0xf1,0x6b,0xc9,0x1b,0xb1,
    0x3c,0xb6,0xd9,0x32,0x24,0x8d,0xf2,0x82,0xb4,0xf9,0xdb,0x7d,0x44,0xfb,0x1e,0xd4,
    0xea,0x5d,0x35,0x69,0x23,0x71,0x57,0x01,0x06,0xe4,0x55,0x9a,0xa4,0x58,0x56,0xc7,
    0x4a,0x8c,0x8a,0xd6,0x6a,0x49,0x70,0xc5,0x8e,0x0a,0x62,0xdc,0x29,0x4b,0x42,0x41,
    0xcb,0x2b,0xb7,0xce,0x08,0xa1,0x76,0x1d,0x1a,0xb8,0xe3,0xcc,0x7e,0x48,0x20,0xe6,
    0xf8,0x45,0x93,0xde,0xc3,0x63,0x0f,0xb0,0xac,0x5c,0xba,0xdf,0x07,0x77,0xe7,0x4e,
    0x1f,0x28,0x10,0x6c,0x59,0xd3,0xdd,0x2d,0x65,0x39,0xb2,0x74,0x84,0x3d,0xf4,0xbd,
    0xc7,0x79,0x60,0x0b,0x4d,0x33,0x36,0x25,0xbc,0xe0,0x09,0xcf,0x5b,0xe2,0x38,0x9e,
    0xc0,0xef,0xd2,0x16,0x05,0xbe,0x53,0xf7,0xc2,0xc6,0xa2,0x24,0x98,0x1c,0xad,0x04
};

static const u32 diffusion[32] = {
    0xf26cb481,0x16a5dc92,0x3c5ba924,0x79b65248,0x2fc64b18,0x615acd29,0xc3b59a42,0x976b2584,
    0x6cf281b4,0xa51692dc,0x5b3c24a9,0xb6794852,0xc62f184b,0x5a6129cd,0xb5c3429a,0x6b978425,
    0xb481f26c,0xdc9216a5,0xa9243c5b,0x524879b6,0x4b182fc6,0xcd29615a,0x9a42c3b5,0x2584976b,
    0x81b46cf2,0x92dca516,0x24a95b3c,0x4852b679,0x184bc62f,0x29cd5a61,0x429ab5c3,0x84256b97
};

// 8-byte LUT for all 256 possible byte-masks
static const uint8_t mask8_lut[256][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00}, {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00}, {0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00},
    {0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00}, {0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00}, {0xFF,0x00,0x00,0xFF,0x00,0x00,0x00,0x00},
    {0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00}, {0xFF,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00},
    {0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00}, {0xFF,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00},
    {0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00}, {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00}, {0xFF,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},
    {0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0x00}, {0xFF,0xFF,0x00,0x00,0xFF,0x00,0x00,0x00},
    {0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00}, {0xFF,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00},
    {0x00,0xFF,0xFF,0x00,0xFF,0x00,0x00,0x00}, {0xFF,0xFF,0xFF,0x00,0xFF,0x00,0x00,0x00},
    {0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00}, {0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00},
    {0x00,0xFF,0x00,0xFF,0xFF,0x00,0x00,0x00}, {0xFF,0xFF,0x00,0xFF,0xFF,0x00,0x00,0x00},
    {0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00}, {0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00},
    {0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00}, {0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00}, {0xFF,0x00,0x00,0x00,0x00,0xFF,0x00,0x00},
    {0x00,0xFF,0x00,0x00,0x00,0xFF,0x00,0x00}, {0xFF,0xFF,0x00,0x00,0x00,0xFF,0x00,0x00},
    {0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00}, {0xFF,0x00,0xFF,0x00,0x00,0xFF,0x00,0x00},
    {0x00,0xFF,0xFF,0x00,0x00,0xFF,0x00,0x00}, {0xFF,0xFF,0xFF,0x00,0x00,0xFF,0x00,0x00},
    {0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00}, {0xFF,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00},
    {0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0x00}, {0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00,0x00},
    {0x00,0x00,0xFF,0xFF,0x00,0xFF,0x00,0x00}, {0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00,0x00},
    {0x00,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0x00}, {0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0x00},
    {0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00}, {0xFF,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00},
    {0x00,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00}, {0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00},
    {0x00,0x00,0xFF,0x00,0xFF,0xFF,0x00,0x00}, {0xFF,0x00,0xFF,0x00,0xFF,0xFF,0x00,0x00},
    {0x00,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0x00}, {0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0x00},
    {0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00}, {0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00},
    {0x00,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x00}, {0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x00},
    {0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00}, {0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00},
    {0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00}, {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00}, {0xFF,0x00,0x00,0x00,0x00,0x00,0xFF,0x00},
    {0x00,0xFF,0x00,0x00,0x00,0x00,0xFF,0x00}, {0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0x00},
    {0x00,0x00,0xFF,0x00,0x00,0x00,0xFF,0x00}, {0xFF,0x00,0xFF,0x00,0x00,0x00,0xFF,0x00},
    {0x00,0xFF,0xFF,0x00,0x00,0x00,0xFF,0x00}, {0xFF,0xFF,0xFF,0x00,0x00,0x00,0xFF,0x00},
    {0x00,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00}, {0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0x00},
    {0x00,0xFF,0x00,0xFF,0x00,0x00,0xFF,0x00}, {0xFF,0xFF,0x00,0xFF,0x00,0x00,0xFF,0x00},
    {0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0x00}, {0xFF,0x00,0xFF,0xFF,0x00,0x00,0xFF,0x00},
    {0x00,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0x00}, {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0x00},
    {0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00}, {0xFF,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00},
    {0x00,0xFF,0x00,0x00,0xFF,0x00,0xFF,0x00}, {0xFF,0xFF,0x00,0x00,0xFF,0x00,0xFF,0x00},
    {0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00}, {0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00},
    {0x00,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00}, {0xFF,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00},
    {0x00,0x00,0x00,0xFF,0xFF,0x00,0xFF,0x00}, {0xFF,0x00,0x00,0xFF,0xFF,0x00,0xFF,0x00},
    {0x00,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00}, {0xFF,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00},
    {0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0x00}, {0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0x00},
    {0x00,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0x00}, {0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0x00},
    {0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00}, {0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00},
    {0x00,0xFF,0x00,0x00,0x00,0xFF,0xFF,0x00}, {0xFF,0xFF,0x00,0x00,0x00,0xFF,0xFF,0x00},
    {0x00,0x00,0xFF,0x00,0x00,0xFF,0xFF,0x00}, {0xFF,0x00,0xFF,0x00,0x00,0xFF,0xFF,0x00},
    {0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00}, {0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00},
    {0x00,0x00,0x00,0xFF,0x00,0xFF,0xFF,0x00}, {0xFF,0x00,0x00,0xFF,0x00,0xFF,0xFF,0x00},
    {0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0x00}, {0xFF,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0x00},
    {0x00,0x00,0xFF,0xFF,0x00,0xFF,0xFF,0x00}, {0xFF,0x00,0xFF,0xFF,0x00,0xFF,0xFF,0x00},
    {0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00}, {0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00},
    {0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00}, {0xFF,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00},
    {0x00,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x00}, {0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x00},
    {0x00,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0x00}, {0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0x00},
    {0x00,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00}, {0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00},
    {0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00}, {0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00},
    {0x00,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0x00}, {0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0x00},
    {0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00}, {0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00},
    {0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00}, {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, {0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
    {0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0xFF}, {0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0xFF},
    {0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0xFF}, {0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0xFF},
    {0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF}, {0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF},
    {0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0xFF}, {0xFF,0x00,0x00,0xFF,0x00,0x00,0x00,0xFF},
    {0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0xFF}, {0xFF,0xFF,0x00,0xFF,0x00,0x00,0x00,0xFF},
    {0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0xFF}, {0xFF,0x00,0xFF,0xFF,0x00,0x00,0x00,0xFF},
    {0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xFF}, {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0xFF},
    {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0xFF}, {0xFF,0x00,0x00,0x00,0xFF,0x00,0x00,0xFF},
    {0x00,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF}, {0xFF,0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF},
    {0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0xFF}, {0xFF,0x00,0xFF,0x00,0xFF,0x00,0x00,0xFF},
    {0x00,0xFF,0xFF,0x00,0xFF,0x00,0x00,0xFF}, {0xFF,0xFF,0xFF,0x00,0xFF,0x00,0x00,0xFF},
    {0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF}, {0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF},
    {0x00,0xFF,0x00,0xFF,0xFF,0x00,0x00,0xFF}, {0xFF,0xFF,0x00,0xFF,0xFF,0x00,0x00,0xFF},
    {0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0xFF}, {0xFF,0x00,0xFF,0xFF,0xFF,0x00,0x00,0xFF},
    {0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF}, {0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF},
    {0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF}, {0xFF,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF},
    {0x00,0xFF,0x00,0x00,0x00,0xFF,0x00,0xFF}, {0xFF,0xFF,0x00,0x00,0x00,0xFF,0x00,0xFF},
    {0x00,0x00,0xFF,0x00,0x00,0xFF,0x00,0xFF}, {0xFF,0x00,0xFF,0x00,0x00,0xFF,0x00,0xFF},
    {0x00,0xFF,0xFF,0x00,0x00,0xFF,0x00,0xFF}, {0xFF,0xFF,0xFF,0x00,0x00,0xFF,0x00,0xFF},
    {0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF}, {0xFF,0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF},
    {0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF}, {0xFF,0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF},
    {0x00,0x00,0xFF,0xFF,0x00,0xFF,0x00,0xFF}, {0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00,0xFF},
    {0x00,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0xFF}, {0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0x00,0xFF},
    {0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0xFF}, {0xFF,0x00,0x00,0x00,0xFF,0xFF,0x00,0xFF},
    {0x00,0xFF,0x00,0x00,0xFF,0xFF,0x00,0xFF}, {0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0xFF},
    {0x00,0x00,0xFF,0x00,0xFF,0xFF,0x00,0xFF}, {0xFF,0x00,0xFF,0x00,0xFF,0xFF,0x00,0xFF},
    {0x00,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0xFF}, {0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0x00,0xFF},
    {0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF}, {0xFF,0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF},
    {0x00,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF}, {0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF},
    {0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0xFF}, {0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0xFF},
    {0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF}, {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF},
    {0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF}, {0xFF,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF},
    {0x00,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF}, {0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF},
    {0x00,0x00,0xFF,0x00,0x00,0x00,0xFF,0xFF}, {0xFF,0x00,0xFF,0x00,0x00,0x00,0xFF,0xFF},
    {0x00,0xFF,0xFF,0x00,0x00,0x00,0xFF,0xFF}, {0xFF,0xFF,0xFF,0x00,0x00,0x00,0xFF,0xFF},
    {0x00,0x00,0x00,0xFF,0x00,0x00,0xFF,0xFF}, {0xFF,0x00,0x00,0xFF,0x00,0x00,0xFF,0xFF},
    {0x00,0xFF,0x00,0xFF,0x00,0x00,0xFF,0xFF}, {0xFF,0xFF,0x00,0xFF,0x00,0x00,0xFF,0xFF},
    {0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF}, {0xFF,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF},
    {0x00,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF}, {0xFF,0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF},
    {0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0xFF}, {0xFF,0x00,0x00,0x00,0xFF,0x00,0xFF,0xFF},
    {0x00,0xFF,0x00,0x00,0xFF,0x00,0xFF,0xFF}, {0xFF,0xFF,0x00,0x00,0xFF,0x00,0xFF,0xFF},
    {0x00,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF}, {0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF},
    {0x00,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0xFF}, {0xFF,0xFF,0xFF,0x00,0xFF,0x00,0xFF,0xFF},
    {0x00,0x00,0x00,0xFF,0xFF,0x00,0xFF,0xFF}, {0xFF,0x00,0x00,0xFF,0xFF,0x00,0xFF,0xFF},
    {0x00,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0xFF}, {0xFF,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0xFF},
    {0x00,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF}, {0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF},
    {0x00,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF}, {0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF},
    {0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF}, {0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF},
    {0x00,0xFF,0x00,0x00,0x00,0xFF,0xFF,0xFF}, {0xFF,0xFF,0x00,0x00,0x00,0xFF,0xFF,0xFF},
    {0x00,0x00,0xFF,0x00,0x00,0xFF,0xFF,0xFF}, {0xFF,0x00,0xFF,0x00,0x00,0xFF,0xFF,0xFF},
    {0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF}, {0xFF,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF},
    {0x00,0x00,0x00,0xFF,0x00,0xFF,0xFF,0xFF}, {0xFF,0x00,0x00,0xFF,0x00,0xFF,0xFF,0xFF},
    {0x00,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF}, {0xFF,0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF},
    {0x00,0x00,0xFF,0xFF,0x00,0xFF,0xFF,0xFF}, {0xFF,0x00,0xFF,0xFF,0x00,0xFF,0xFF,0xFF},
    {0x00,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF}, {0xFF,0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF},
    {0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF}, {0xFF,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF},
    {0x00,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF}, {0xFF,0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF},
    {0x00,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0xFF}, {0xFF,0x00,0xFF,0x00,0xFF,0xFF,0xFF,0xFF},
    {0x00,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF}, {0xFF,0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF},
    {0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF}, {0xFF,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF},
    {0x00,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF}, {0xFF,0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF},
    {0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, {0xFF,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
    {0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}, {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}
};

// Exploration statistics
static long long total_nodes_explored = 0;
static long long winning_paths = 0;
static long long dead_ends = 0;
static long long solutions_found = 0;

// CSV output file
static FILE *csv_file = NULL;

// Values that have choices in inv_low (we'll identify these during precomputation)
static u8 choice_values[16];
static int num_choice_values = 0;

__attribute__((always_inline))
static inline u8 dot_row_optimized(u32 row_mask, const u8 * __restrict state)
{
    // Check if mask is sparse enough to use scalar path
    if (__builtin_popcount(row_mask) <= 4) {
        // Use scalar approach for sparse masks
        u8 acc = 0;
        while (row_mask) {
            int k = __builtin_ctz(row_mask);
            acc ^= state[k];
            row_mask &= row_mask - 1;
        }
        return acc;
    }
    
    // ARM64 NEON path using 8-byte LUT
    uint8_t lo8  = (uint8_t)(row_mask        & 0xFF);
    uint8_t lo16 = (uint8_t)((row_mask >>  8) & 0xFF);
    uint8_t hi16 = (uint8_t)((row_mask >> 16) & 0xFF);
    uint8_t hi8  = (uint8_t)((row_mask >> 24) & 0xFF);

    uint8x8_t mask_lo8   = vld1_u8(mask8_lut[lo8]);
    uint8x8_t mask_lo16  = vld1_u8(mask8_lut[lo16]);
    uint8x8_t mask_hi16  = vld1_u8(mask8_lut[hi16]);
    uint8x8_t mask_hi8   = vld1_u8(mask8_lut[hi8]);

    uint8x16_t mask_low128  = vcombine_u8(mask_lo8,  mask_lo16);
    uint8x16_t mask_high128 = vcombine_u8(mask_hi16, mask_hi8);

    uint8x16_t state_low128  = vld1q_u8(state + 0);
    uint8x16_t state_high128 = vld1q_u8(state + 16);

    uint8x16_t and_low  = vandq_u8(state_low128,  mask_low128);
    uint8x16_t and_high = vandq_u8(state_high128, mask_high128);
    uint8x16_t acc_vec  = veorq_u8(and_low, and_high);

    uint8x8_t lo_lane = vget_low_u8(acc_vec);
    uint8x8_t hi_lane = vget_high_u8(acc_vec);
    uint8x8_t x1 = veor_u8(lo_lane, hi_lane);
    uint8x8_t x2 = veor_u8(x1, vext_u8(x1, x1, 4));
    uint8x8_t x3 = veor_u8(x2, vext_u8(x2, x2, 2));
    uint8x8_t x4 = veor_u8(x3, vext_u8(x3, x3, 1));
    return vget_lane_u8(x4, 0);
}

static int invert32(const u32 A[32], u32 Ainv[32])
{
    uint64_t aug[32];
    for (int r = 0; r < 32; ++r)
        aug[r] = ((uint64_t)A[r]) | (1ULL << (32 + r));

    for (int c = 0; c < 32; ++c) {
        int piv = c;
        while (piv < 32 && !(aug[piv] >> c & 1)) ++piv;
        if (piv == 32) return -1;
        if (piv != c) { uint64_t tmp = aug[c]; aug[c] = aug[piv]; aug[piv] = tmp; }
        for (int r = 0; r < 32; ++r)
            if (r != c && (aug[r] >> c & 1)) aug[r] ^= aug[c];
    }

    for (int r = 0; r < 32; ++r)
        Ainv[r] = (u32)(aug[r] >> 32);
    return 0;
}

static u8  inv_low[256][256] __attribute__((aligned(64)));
static u8  inv_low_count[256] __attribute__((aligned(64)));
static u8  inv_high[256][256] __attribute__((aligned(64)));
static u8  inv_high_count[256] __attribute__((aligned(64)));
static u32 invM[32] __attribute__((aligned(32)));
static u8  odd_of[16][256] __attribute__((aligned(64)));
static u8  is_possible[16][256] __attribute__((aligned(64)));

static const u8 target[16] = "Hire me!!!!!!!!";

static void precompute(void)
{
    for (int b = 0; b < 256; ++b) inv_low_count[b] = 0;
    for (int x = 0; x < 256; ++x) {
        u8 y = confusion[x];
        inv_low[y][inv_low_count[y]++] = (u8)x;
    }
    
    // Identify which values have multiple choices
    num_choice_values = 0;
    for (int b = 0; b < 256; ++b) {
        if (inv_low_count[b] > 1 && num_choice_values < 16) {
            choice_values[num_choice_values++] = (u8)b;
        }
    }
    
    for (int b = 0; b < 256; ++b) inv_high_count[b] = 0;
    for (int x = 0; x < 256; ++x) {
        u8 y = confusion[x + 256];
        inv_high[y][inv_high_count[y]++] = (u8)x;
    }
    
    if (invert32(diffusion, invM)) {
        fprintf(stderr, "[FATAL] diffusion matrix not invertible!\n");
        exit(EXIT_FAILURE);
    }
    
    const u8 *Slo = confusion;
    for (int pos = 0; pos < 16; ++pos) {
        for (int ev = 0; ev < 256; ++ev) {
            u8 need = Slo[ev] ^ target[pos];
            if (inv_high_count[need] > 0) {
                odd_of[pos][ev] = inv_high[need][0];
                is_possible[pos][ev] = 1;
            } else {
                odd_of[pos][ev] = 0;
                is_possible[pos][ev] = 0;
            }
        }
    }
}

// Data structure to track choices made to reach current node
typedef struct {
    u8 choice_made[256]; // For each value that had a choice, which option (0-based) was selected
    int depth;
    int on_winning_path; // Will be determined after exploration
    long long next_combinations; // Total combinations available from this node
} node_data_t;

// Structure to track a complete successful path
typedef struct {
    u8 choice_sequences[16][256]; // For each choice dimension, sequence of choices made
    int sequence_lengths[16]; // Length of sequence for each dimension
    u8 final_solution[32]; // The final solution state
    int path_id; // Unique identifier for this path
} successful_path_t;

// Global storage for successful paths
static successful_path_t successful_paths[1000]; // Store up to 1000 successful paths
static int num_successful_paths = 0;
static FILE *path_sequences_file = NULL;

static u8 state_buffer[257][32] __attribute__((aligned(64)));

// Forward declaration for recursive marking
static int check_winning_path(u8 state[32], int round, node_data_t *node_data);

// Log node data to CSV
static void log_node_to_csv(const node_data_t *node)
{
    if (!csv_file) return;
    
    // Write choices for each choice value
    for (int i = 0; i < num_choice_values; ++i) {
        u8 val = choice_values[i];
        fprintf(csv_file, "%d,", node->choice_made[val]);
    }
    
    // Write other data
    fprintf(csv_file, "%d,%lld,%d\n", 
            node->on_winning_path, 
            node->next_combinations, 
            node->depth);
}

// Recursive DFS that explores all paths and logs data
static int dfs_explore_all(u8 state[32], int round, node_data_t *parent_node, successful_path_t *current_path)
{
    total_nodes_explored++;
    
    node_data_t current_node;
    if (parent_node) {
        memcpy(&current_node, parent_node, sizeof(node_data_t));
        current_node.depth = parent_node->depth + 1;
    } else {
        memset(&current_node, 0, sizeof(node_data_t));
        current_node.depth = 0;
    }
    
    if (round == 256) {
        // Found solution - record the complete path
        current_node.on_winning_path = 1;
        current_node.next_combinations = 0;
        log_node_to_csv(&current_node);
        solutions_found++;
        winning_paths++;
        
        // Store this successful path
        if (num_successful_paths < 1000 && current_path) {
            memcpy(&successful_paths[num_successful_paths], current_path, sizeof(successful_path_t));
            memcpy(successful_paths[num_successful_paths].final_solution, state, 32);
            successful_paths[num_successful_paths].path_id = num_successful_paths + 1;
            num_successful_paths++;
        }
        
        return 1;
    }
    
    // Compute v and choices for this round
    u8 v[32];
    u8 choices_per_pos[32];
    const u8 *choices_ptr[32];
    int valid_state = 1;
    long long total_combinations = 1;
    
    for (int j = 0; j < 32; ++j) {
        const u8 t = dot_row_optimized(invM[j], state);
        v[j] = t;
        const int c = inv_low_count[t];
        if (!c) { 
            valid_state = 0; 
            break; 
        }
        
        choices_per_pos[j] = c;
        choices_ptr[j] = inv_low[t];
        total_combinations *= c;
    }
    
    if (!valid_state) {
        current_node.on_winning_path = 0;
        current_node.next_combinations = 0;
        log_node_to_csv(&current_node);
        dead_ends++;
        return 0;
    }
    
    current_node.next_combinations = total_combinations;
    
    // Explore all combinations
    u8 idx[32];
    memset(idx, 0, 32);
    int has_winning_child = 0;
    
    do {
        // Generate new state from current idx[]
        u8 new_state[32];
        for (int j = 0; j < 32; ++j) {
            new_state[j] = choices_ptr[j][idx[j]];
        }
        
        // Update choice tracking for values with multiple options
        node_data_t child_node = current_node;
        successful_path_t child_path;
        if (current_path) {
            memcpy(&child_path, current_path, sizeof(successful_path_t));
        } else {
            memset(&child_path, 0, sizeof(successful_path_t));
        }
        
        for (int j = 0; j < 32; ++j) {
            u8 val = v[j];
            if (inv_low_count[val] > 1) {
                child_node.choice_made[val] = idx[j];
                
                // Track choice sequence for this dimension
                // Find which choice dimension this corresponds to
                for (int dim = 0; dim < num_choice_values; ++dim) {
                    if (choice_values[dim] == val) {
                        if (child_path.sequence_lengths[dim] < 256) {
                            child_path.choice_sequences[dim][child_path.sequence_lengths[dim]] = idx[j];
                            child_path.sequence_lengths[dim]++;
                        }
                        break;
                    }
                }
            }
        }
        
        // Recursively explore this child
        int child_wins = dfs_explore_all(new_state, round + 1, &child_node, &child_path);
        if (child_wins) {
            has_winning_child = 1;
        }
        
        // Increment counter (mixed-radix)
        int k = 0;
        for (; k < 32; ++k) {
            if (++idx[k] < choices_per_pos[k]) {
                break;  // No carry needed
            }
            idx[k] = 0;  // Wrap and continue to next digit
        }
        
        if (k == 32) break; // Exhausted all combinations
        
    } while (1);
    
    // Mark current node based on whether it has winning children
    current_node.on_winning_path = has_winning_child;
    if (has_winning_child) {
        winning_paths++;
    }
    
    // Log the current node (we log after exploring children to know winning status)
    log_node_to_csv(&current_node);
    
    return has_winning_child;
}

static void build_final_state(u8 c[32])
{
    u8 v[32];
    int max_attempts = 1000000;
    
    for (int attempt = 0; attempt < max_attempts; ++attempt) {
        int valid_state = 1;
        for (int pos = 0; pos < 16 && valid_state; ++pos) {
            int found = 0;
            for (int tries = 0; tries < 256; ++tries) {
                int ev = rand() % 256;
                
                if (is_possible[pos][ev]) {
                    u8 od = odd_of[pos][ev];
                    c[2*pos] = (u8)ev;
                    c[2*pos + 1] = od;
                    found = 1;
                    break;
                }
            }
            
            if (!found) {
                valid_state = 0;
            }
        }
        
        if (!valid_state) {
            continue;
        }
        
        int all_valid = 1;
        for (int j = 0; j < 32; ++j) {
            v[j] = dot_row_optimized(invM[j], c);
            if (inv_low_count[v[j]] == 0) {
                all_valid = 0;
                break;
            }
        }
        
        if (all_valid) {
            return;
        }
        
        for (int fix_attempts = 0; fix_attempts < 10; ++fix_attempts) {
            int pos = rand() % 16;
            int ev = rand() % 256;
            
            if (is_possible[pos][ev]) {
                u8 od = odd_of[pos][ev];
                c[2*pos] = (u8)ev;
                c[2*pos + 1] = od;
                
                all_valid = 1;
                for (int j = 0; j < 32; ++j) {
                    v[j] = dot_row_optimized(invM[j], c);
                    if (inv_low_count[v[j]] == 0) {
                        all_valid = 0;
                        break;
                    }
                }
                
                if (all_valid) {
                    return;
                }
            }
        }
    }
    
    fprintf(stderr, "[FATAL] could not build a legal end‑state\n");
    exit(EXIT_FAILURE);
}

static void Forward(const u8 in[32], u8 out[32])
{
    u8 c[32];
    memcpy(c, in, 32);

    u8 d[32];
    for (int r = 0; r < 256; ++r) {
        for (int j = 0; j < 32; ++j) { d[j] = confusion[c[j]]; c[j] = 0; }
        for (int j = 0; j < 32; ++j)
            for (int k = 0; k < 32; ++k)
                if (diffusion[j] >> k & 1) c[j] ^= d[k];
    }
    for (int i = 0; i < 16; ++i)
        out[i] = confusion[c[2*i]] ^ confusion[c[2*i+1] + 256];
}

int main(void)
{
    srand(time(NULL));
    
    printf("Starting DFS exploration analysis (solution states only)...\n");
    precompute();
    
    printf("Choice values with multiple options: ");
    for (int i = 0; i < num_choice_values; ++i) {
        printf("%d ", choice_values[i]);
    }
    printf("\n");
    
    const int TARGET_ROUNDS = 10; // 10 rounds where we find solutions
    const int MAX_ATTEMPTS_PER_ROUND = 10000; // Maximum attempts per round to find a solution
    
    for (int round = 1; round <= TARGET_ROUNDS; ++round) {
        printf("\n=== ROUND %d/%d ===\n", round, TARGET_ROUNDS);
        
        int found_solution_this_round = 0;
        for (int attempt = 1; attempt <= MAX_ATTEMPTS_PER_ROUND && !found_solution_this_round; ++attempt) {
            printf("  Attempt %d/%d: Building and testing final state...\n", attempt, MAX_ATTEMPTS_PER_ROUND);
            u8 c256[32];
            build_final_state(c256);
            
            // First, quickly check if this final state has ANY solution
            printf("    Quick solution check...\n");
            total_nodes_explored = 0;
            winning_paths = 0;
            dead_ends = 0;
            solutions_found = 0;
            
            int has_solution = dfs_explore_all(c256, 0, NULL, NULL);
            
            if (has_solution) {
                found_solution_this_round = 1;
                printf("    ✓ Round %d: Found solution state! Starting full exploration...\n", round);
            
                // Open CSV file for this specific round
                char csv_filename[256];
                snprintf(csv_filename, sizeof(csv_filename), "dfs_exploration_round_%d.csv", round);
                csv_file = fopen(csv_filename, "w");
                if (!csv_file) {
                    fprintf(stderr, "Failed to open CSV file %s for writing\n", csv_filename);
                    continue;
                }
                
                // Write CSV header
                for (int i = 0; i < num_choice_values; ++i) {
                    fprintf(csv_file, "choice_%d,", choice_values[i]);
                }
                fprintf(csv_file, "on_winning_path,next_combinations,depth\n");
                
                // Reset counters and do full exploration with logging
                total_nodes_explored = 0;
                winning_paths = 0;
                dead_ends = 0;
                solutions_found = 0;
                
                // Reset successful paths tracking
                num_successful_paths = 0;
                
                // Open file for path sequences
                char path_filename[256];
                snprintf(path_filename, sizeof(path_filename), "path_sequences_round_%d.txt", round);
                path_sequences_file = fopen(path_filename, "w");
                
                successful_path_t initial_path;
                memset(&initial_path, 0, sizeof(successful_path_t));
                
                dfs_explore_all(c256, 0, NULL, &initial_path);
                
                fclose(csv_file);
                csv_file = NULL;
                
                // Output choice sequences for all successful paths
                if (path_sequences_file && num_successful_paths > 0) {
                    fprintf(path_sequences_file, "CHOICE SEQUENCES FOR SUCCESSFUL PATHS - ROUND %d\n", round);
                    fprintf(path_sequences_file, "============================================================\n\n");
                    fprintf(path_sequences_file, "Found %d successful paths\n\n", num_successful_paths);
                    
                    for (int path_idx = 0; path_idx < num_successful_paths; ++path_idx) {
                        successful_path_t *path = &successful_paths[path_idx];
                        fprintf(path_sequences_file, "PATH %d:\n", path->path_id);
                        fprintf(path_sequences_file, "--------------------\n");
                        
                        fprintf(path_sequences_file, "Final solution: ");
                        for (int i = 0; i < 32; ++i) {
                            fprintf(path_sequences_file, "%02x", path->final_solution[i]);
                        }
                        fprintf(path_sequences_file, "\n\n");
                        
                        fprintf(path_sequences_file, "Choice sequences by dimension:\n");
                        for (int dim = 0; dim < num_choice_values; ++dim) {
                            if (path->sequence_lengths[dim] > 0) {
                                fprintf(path_sequences_file, "  Dimension %d (value %d): ", 
                                       dim, choice_values[dim]);
                                for (int seq_idx = 0; seq_idx < path->sequence_lengths[dim]; ++seq_idx) {
                                    fprintf(path_sequences_file, "%d ", path->choice_sequences[dim][seq_idx]);
                                }
                                fprintf(path_sequences_file, "(%d choices)\n", path->sequence_lengths[dim]);
                            } else {
                                fprintf(path_sequences_file, "  Dimension %d (value %d): No choices made\n", 
                                       dim, choice_values[dim]);
                            }
                        }
                        fprintf(path_sequences_file, "\n");
                    }
                }
                
                if (path_sequences_file) {
                    fclose(path_sequences_file);
                    path_sequences_file = NULL;
                }
                
                printf("    Exploration complete for round %d:\n", round);
                printf("      Total nodes explored: %lld\n", total_nodes_explored);
                printf("      Nodes on winning paths: %lld\n", winning_paths);
                printf("      Dead end nodes: %lld\n", dead_ends);
                printf("      Solutions found: %lld\n", solutions_found);
                printf("      Successful paths tracked: %d\n", num_successful_paths);
                printf("      Data saved to: %s\n", csv_filename);
                printf("      Choice sequences saved to: %s\n", path_filename);
                
                // Also validate one solution by running it through Forward()
                printf("    Validating solution...\n");
                u8 test_solution[32];
            
                // Find one solution by doing a quick DFS
                typedef struct {
                    int round;
                    u8 idx[32];
                    u8 choices_per_pos[32];
                    const u8 *choices_ptr[32];
                    u8 v[32];
                    int counter_pos;
                } quick_dfs_frame_t;
                
                quick_dfs_frame_t stack[257];
                int sp = 0;
                
                memcpy(state_buffer[0], c256, 32);
                stack[sp].round = 0;
                memset(stack[sp].idx, 0, 32);
                stack[sp].counter_pos = 0;
                sp++;
                
                int found_solution = 0;
                while (sp > 0 && !found_solution) {
                    quick_dfs_frame_t *frame = &stack[sp - 1];
                    
                    if (frame->round == 256) {
                        memcpy(test_solution, state_buffer[sp - 1], 32);
                        found_solution = 1;
                        break;
                    }
                    
                    if (frame->counter_pos == 0) {
                        int valid_state = 1;
                        for (int j = 0; j < 32; ++j) {
                            const u8 t = dot_row_optimized(invM[j], state_buffer[sp - 1]);
                            frame->v[j] = t;
                            const int c = inv_low_count[t];
                            if (!c) { 
                                valid_state = 0; 
                                break; 
                            }
                            frame->choices_per_pos[j] = c;
                            frame->choices_ptr[j] = inv_low[t];
                        }
                        
                        if (!valid_state) {
                            sp--;
                            continue;
                        }
                    }
                    
                    if (frame->counter_pos == 0) {
                        u8 *new_state = state_buffer[sp];
                        for (int j = 0; j < 32; ++j) {
                            new_state[j] = frame->choices_ptr[j][frame->idx[j]];
                        }
                        
                        stack[sp].round = frame->round + 1;
                        memset(stack[sp].idx, 0, 32);
                        stack[sp].counter_pos = 0;
                        sp++;
                        frame->counter_pos = 1;
                        continue;
                    }
                    
                    int k = 0;
                    for (; k < 32; ++k) {
                        if (++frame->idx[k] < frame->choices_per_pos[k]) {
                            break;
                        }
                        frame->idx[k] = 0;
                    }
                    
                    if (k == 32) {
                        sp--;
                    } else {
                        frame->counter_pos = 0;
                    }
                }
                
                if (found_solution) {
                    u8 test_out[16];
                    Forward(test_solution, test_out);
                    if (memcmp(test_out, target, 16) == 0) {
                        printf("    ✓ Solution validation passed!\n");
                    } else {
                        printf("    ✗ Solution validation FAILED!\n");
                        printf("      Expected: ");
                        for (int i = 0; i < 16; ++i) printf("%02x", target[i]);
                        printf("\n      Got:      ");
                        for (int i = 0; i < 16; ++i) printf("%02x", test_out[i]);
                        printf("\n");
                    }
                } else {
                    printf("    ✗ Could not find solution for validation!\n");
                }
                
            } else {
                printf("    ✗ No solutions found, trying next attempt...\n");
            }
        }
        
        if (!found_solution_this_round) {
            printf("  ✗ Round %d: Could not find any solution state after %d attempts!\n", round, MAX_ATTEMPTS_PER_ROUND);
        }
    }
    
    printf("\nCompleted %d rounds of exploration.\n", TARGET_ROUNDS);
    
    return 0;
}