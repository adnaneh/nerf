/******************************************************************
 * Test version to count variables and clauses
 ******************************************************************/
#include <cryptominisat5/cryptominisat.h>
#include <array>
#include <vector>
#include <cstdint>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <chrono>
#include <iomanip>

using namespace CMSat;

static inline Lit new_lit(SATSolver& S) {
    S.new_var();
    return Lit(S.nVars() - 1, false);
}
static inline Lit neg(const Lit& l) { return ~l; }

/* exactly-one using a Sinz sequential counter - O(n) clauses, O(n) fresh vars */
static void exactly_one_seq(SATSolver& S, const std::vector<Lit>& x)
{
    if (x.size() <= 1) return;
    std::vector<Lit> a(x.size() - 1);
    for (auto& v : a) v = new_lit(S);

    S.add_clause(x);                         //  ≥1
    S.add_clause({neg(x[0]),     a[0]});     //  x0 → a0
    for (size_t i = 1; i + 1 < x.size(); ++i) {
        S.add_clause({neg(a[i-1]), a[i]});   //  ai-1 → ai
        S.add_clause({neg(x[i]),   a[i]});   //  xi  → ai
        S.add_clause({neg(x[i]), neg(a[i-1])}); // xi  → ¬ai-1
    }
    S.add_clause({neg(x.back()), neg(a.back())}); // xn-1 → ¬an-1
}

static void encode_sbox_byte(
        SATSolver&               S,
        const std::array<Lit, 8>& in_bits,
        std::array<Lit, 8>&       out_bits,
        const uint8_t            confusion[256])
{
    size_t vars_before = S.nVars();
    
    /* 1. selector literals s_v  (v = 0..255) */
    std::vector<Lit> sel(256);
    for (int v = 0; v < 256; ++v) sel[v] = new_lit(S);
    exactly_one_seq(S, sel);                   // exactly one active selector

    /* 2. link selectors to input pattern */
    for (int v = 0; v < 256; ++v) {
        for (int b = 0; b < 8; ++b) {
            bool bit = (v >> b) & 1;
            S.add_clause({ neg(sel[v]), bit ? in_bits[b] : neg(in_bits[b]) });
        }
    }

    /* 3. create 8 output literals  */
    for (int b = 0; b < 8; ++b) out_bits[b] = new_lit(S);

    /* 4. tie output bits to the constant S-box entry confusion[v] */
    for (int v = 0; v < 256; ++v)
        for (int b = 0; b < 8; ++b) {
            bool bit = (confusion[v] >> b) & 1;
            S.add_clause({ neg(sel[v]), bit ? out_bits[b] : neg(out_bits[b]) });
        }
    
    size_t vars_after = S.nVars();
    std::cout << "S-box added " << (vars_after - vars_before) << " variables (total: " << vars_after << ")\n";
}

int main()
{
    SATSolver S;
    
    std::array<uint8_t, 256> confusion = {
        0xac,0xd1,0x25,0x94,0x1f,0xb3,0x33,0x28,0x7c,0x2b,0x17,0xbc,0xf6,0xb0,0x55,0x5d,
        0x8f,0xd2,0x48,0xd4,0xd3,0x78,0x62,0x1a,0x02,0xf2,0x01,0xc9,0xaa,0xf0,0x83,0x71,
        0x72,0x4b,0x6a,0xe8,0xe9,0x42,0xc0,0x53,0x63,0x66,0x13,0x4a,0xc1,0x85,0xcf,0x0c,
        0x24,0x76,0xa5,0x6e,0xd7,0xa1,0xec,0xc6,0x04,0xc2,0xa2,0x5c,0x81,0x92,0x6c,0xda,
        0xc6,0x86,0xba,0x4d,0x39,0xa0,0x0e,0x8c,0x8a,0xd0,0xfe,0x59,0x96,0x49,0xe6,0xea,
        0x69,0x30,0x52,0x1c,0xe0,0xb2,0x05,0x9b,0x10,0x03,0xa8,0x64,0x51,0x97,0x02,0x09,
        0x8e,0xad,0xf7,0x36,0x47,0xab,0xce,0x7f,0x56,0xca,0x00,0xe3,0xed,0xf1,0x38,0xd8,
        0x26,0x1c,0xdc,0x35,0x91,0x43,0x2c,0x74,0xb4,0x61,0x9d,0x5e,0xe9,0x4c,0xbf,0x77,
        0x16,0x1e,0x21,0x1d,0x2d,0xa9,0x95,0xb8,0xc3,0x8d,0xf8,0xdb,0x34,0xe1,0x84,0xd6,
        0x0b,0x23,0x4e,0xff,0x3c,0x54,0xa7,0x78,0xa4,0x89,0x33,0x6d,0xfb,0x79,0x27,0xc4,
        0xf9,0x40,0x41,0xdf,0xc5,0x82,0x93,0xdd,0xa6,0xef,0xcd,0x8d,0xa3,0xae,0x7a,0xb6,
        0x2f,0xfd,0xbd,0xe5,0x98,0x66,0xf3,0x4f,0x57,0x88,0x90,0x9c,0x0a,0x50,0xe7,0x15,
        0x7b,0x58,0xbc,0x07,0x68,0x3a,0x5f,0xee,0x32,0x9f,0xeb,0xcc,0x18,0x8b,0xe2,0x57,
        0xb7,0x49,0x37,0xde,0xf5,0x99,0x67,0x5b,0x3b,0xbb,0x3d,0xb5,0x2d,0x19,0x2e,0x0d,
        0x93,0xfc,0x7e,0x06,0x08,0xbe,0x3f,0xd9,0x2a,0x70,0x9a,0xc8,0x7d,0xd8,0x46,0x65,
        0x22,0xf4,0xb9,0xa2,0x6f,0x12,0x1b,0x14,0x45,0xc7,0x87,0x31,0x60,0x29,0xf7,0x73
    };

    /* Create input bits for testing */
    std::array<Lit, 8> in_bits;
    for (int b = 0; b < 8; ++b) in_bits[b] = new_lit(S);
    
    std::cout << "Initial variables: " << S.nVars() << std::endl;
    
    /* Test one S-box */
    std::array<Lit, 8> out_bits;
    encode_sbox_byte(S, in_bits, out_bits, confusion.data());
    
    std::cout << "After 1 S-box: " << S.nVars() << " variables\n";
    std::cout << "Per S-box overhead: " << (S.nVars() - 8) / 1 << " variables\n";
    std::cout << "For 64 S-boxes total variables would be: " << 8 + 64 * (S.nVars() - 8) << std::endl;
    
    return 0;
}